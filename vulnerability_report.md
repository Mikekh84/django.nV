# Vulnerability Report - nVisium Task Manager
#### Reviewer 1: Mike Harrison
#### Reviewer 2: Rick Tesmond

#### April, 2016
________________________________________
## Injection
### Exposure
We found an a vulnerability for sql injection within the `upload` function in views.py. The code uses `curs.execute` which does not utilize any validation.

By Exploiting injection, we were able to name our project file `DROP TABLE user` which subsequently dropped all users from the database.

### Repair
In the Upload view, we replaced 
```
            curs.execute(
                "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                (name, upload_path, project_id))
```
with 
```
            file = File(
                name=name,
                path=upload_path,
                project=proj)
            file.save()
```
because using curs.execute directly impacts the Django ORM and bypasses the built in checks. By using the common ORM, we ensure the file information is checked before it is submitted. We tested this with multiple injection attempts.
__________________________________________________
## Broken Auth
### Exposure
We utilized Broken Authentication by directly editing the HTML on the registration page and adding in two input tags `<input type="checkbox" name="is_superuser">` and `<input type="checkbox" name="is_staff">`; when checked, they set the user to staff and superuser status.

By Exploiting Broken Auth, we were able to access the admin page and have full rights over the users in the site

### Repair
We changed the formfield for users from a blacklist "exlude":
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
```
to a whitelist "fields", which covers many more bases by specifying only the things that can be added on the user form field:
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        fields = ('username', 'first_name', 'last_name', 'email', 'password')
```
__________________________________________________
## XSS
### Exposure
We found instances of Cross Site Scripting in many locations designated by {{ something |safe}} (ex. `<a href="/taskManager/search/?q={{q|safe}}" id="loading-btn" class="btn btn-warning btn-xs"><i class="fa fa-refresh"></i> Refresh</a>`) in multiple locations on the site. Namely the base_backend.html, search, edit profile, and album edit. 

By Exploiting injection, we were able to manipulate html by running script commands such as `name"><script>alert("HAHAHAHAH")</script>` in many of the fields to create a screen alert.

### Repair
We fixed this by finding all the possible areas of XSS, like,
```
<span class="username"><i class="fa fa-user fa-fw"></i> {{ user.username|safe }}</span>
```
and removed the `|safe` decorator in the script, like so,
```
<span class="username"><i class="fa fa-user fa-fw"></i> {{ user.username}}</span>
```
This allowed us to still enter scripts but the script did not execute like they did before.

__________________________________________________
## Insecure DOR
### Exposure
We found instances where Insecure Direct Object Reference attacks can occur primarily in the views.py file, where there are no authorization checks whe accessing object mainpulation views. Ex. 
```
def task_create(request, project_id):
    if request.method == 'POST':
        proj = Project.objects.get(pk=project_id)
        text = request.POST.get('text', False)
```
```
def task_edit(request, project_id, task_id):

    proj = Project.objects.get(pk=project_id)
    task = Task.objects.get(pk=task_id)
```

By Exploiting Insecure DOR, I can create, edit, and delete content that is not my own or use these insecure objects to access more information about the user

### Repair
To protect agains Insecure DOR, we included decorators such as,
```
@login_required(login_url='/login')
def task_edit(request, project_id, task_id):

    proj = Project.objects.get(pk=project_id)
    task = Task.objects.get(pk=task_id)
```
that require users to at least be signed in, similarly to how `user.is_authenticated` works. We can also specify users by permissions granted using `user.has_perm('admin')`.
__________________________________________________
## Security Misconfiguration
### Exposure
We found Security Misconfiguration in the by typing in an incorrect URL(`127.0.0.1:8000/taskManager/tut`) and we were returned a Django debug error page with the system urls check.

By exploiting security misconfiguration, we recieved an entire list of all the possible urls for the taskManager site which can expose session data and secret keys.

### Repair
We simply set all the DEBUG statements in settings.py to False, so verbose error messages will not be displayed and session data can remain mostly protected.
```
DEBUG = False
TEMPLATE_DEBUG = False

ALLOWED_HOSTS = []
```
Also storing the Secret_key in a virtual env is an effective way to make stealing session data much more difficult.

_________________________________________
## Sensitive Data Exposure
### Exposure
We found routes for exposure through the site's multiple for fields that effect passwords. Since the sites' current hashing algorithm does not salt passwords, we were able to exploit the passwords stored in the database by entering `SELECT * FROM auth_user`. Although it was beyond us, the unsalted passwords are much easier to de-hash.

By exploiting exposure, we gained access to all of the users' passwords from the database.

### Repair
We fixed the password hashing vulnerability by changing the default hashing algorithm `django.contrib.auth.hashers.MD5PasswordHasher` with a more complicated hashing algorithm, like BCryptPasswordHasher that is already salted (`django.contrib.auth.hashers.BCryptPasswordHasher`). Also storing the `PASSWORD_HASHERS` in the virtualenv will help make getting the password even more difficult.

__________________________________________________
## Missing Function Level Access Control
### Exposure
We found vulnerabilities for MFLAC in the settings.py, specifically with the `manage_groups` view. The view does specify level control AFTER a user already has access to some managerial rights.

So by being signed-in, we were able to access `post` rights in regards to group management; this can be made much more easily if you set yourself to superuser status (see Broken Auth).

### Repair
In the `manage_groups` view:
```
def manage_groups(request):
    user = request.user
    if user.is_authenticated():
        user_list = User.objects.order_by('date_joined')
        if request.method == 'POST':
            post_data = request.POST.dict()
            accesslevel = post_data["accesslevel"].strip()
```
we included another conditional statement that checks if a user is 1) authentication is `True` and 2) if a user has managerial rights before they have access to the post request:
```
def manage_groups(request):
    user = request.user
    if user.is_authenticated():
        logged_in = True
        user_list = User.objects.order_by('date_joined')
        if user.has_perm('can_manage_group'):
            if request.method == 'POST':
                post_data = request.POST.dict()
```

__________________________________________________
## Cross Site Request Forgery
### Exposure
We found exposure to CSRF attacks on many of the forms on the site and the profile view. In views.py,
```
@csrf_exempt
def profile_by_id(request, user_id):
    user = User.objects.get(pk=user_id)
```
is vulnerable to csrf attacks due to the @csrf decorator, which exludes that view from requiring djangos built in csrf validation to view. Many of the form templates also lacked the `{% csrf_token %}` flag, which leaves the sensitive information open to CSRF attacks.
By exploiting CSRF we were able to redirect the save button on the profile page to redirect to a different page by including an `<a href>` tag around the button.

### Repair
We first removed the `@csrf_exempt` decorator from the profile_by_id view, and on the templates that lacked the `{% csrf_token %}` tag; we added on that tag. For example, on the change_password.html template:
```
<form method="post" role="form">
    {% csrf_token %}
      <div class="form-group col-lg-7 col-sm-7">
          <label >Old Password</label>
          <input type="password" name="old_password" class="form-control">
          <label >New Password</label>
          <input type="password" name="new_password" class="form-control">
          <label >New Password (Confirm)</label>
          <input type="password" name="confirm_password" class="form-control">
          <hr>
          <button type="submit" class="btn btn-info">Save</button>
      </div>
</form>
```
