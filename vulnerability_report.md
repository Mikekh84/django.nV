# Vulnerability Report - nVisium Task Manager
#### Reviewer 1: Mike Harrison
#### Reviewer 2: Rick Tesmond

#### April, 2016
________________________________________
## Injection
### Exposure
We found an a vulnerability for sql injection within the `upload` function in views.py. The code uses `curs.execute` which does not utilize any validation.

By Exploiting injection, we were able to name our project file `DROP TABLE user` which subsequently dropped all users from the database.

### Repair
In the Upload view, we replaced 
```
            curs.execute(
                "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
                (name, upload_path, project_id))
```
with 
```
            file = File(
                name=name,
                path=upload_path,
                project=proj)
            file.save()
```
because using curs.execute directly impacts the Django ORM and bypasses the built in checks. By using the common ORM, we ensure the file information is checked before it is submitted. We tested this with multiple injection attempts.
__________________________________________________
## Broken Auth
### Exposure
We utilized Broken Authentication by directly editing the HTML on the registration page and adding in two input tags `<input type="checkbox" name="is_superuser">` and `<input type="checkbox" name="is_staff">`; when checked, they set the user to staff and superuser status.

By Exploiting Broken Auth, we were able to access the admin page and have full rights over the users in the site

### Repair
We changed the formfield for users from a blacklist "exlude":
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        exclude = ['groups', 'user_permissions', 'last_login', 'date_joined', 'is_active']
```
to a whitelist "fields", which covers many more bases by specifying only the things that can be added on the user form field:
```
class UserForm(forms.ModelForm):
    """ User registration form """
    class Meta:
        model = User
        fields = ('username', 'first_name', 'last_name', 'email', 'password')
```
__________________________________________________
## XSS
### Exposure
We found instances of Cross Site Scripting in many locations designated by {{ something |safe}} (ex. `<a href="/taskManager/search/?q={{q|safe}}" id="loading-btn" class="btn btn-warning btn-xs"><i class="fa fa-refresh"></i> Refresh</a>`) in multiple locations on the site. Namely the base_backend.html, search, edit profile, and album edit. 

By Exploiting injection, we were able to manipulate html by running script commands such as `name"><script>alert("HAHAHAHAH")</script>` in many of the fields to create a screen alert.

### Repair
We fixed this by finding all the possible areas of XSS, like,
```
<span class="username"><i class="fa fa-user fa-fw"></i> {{ user.username|safe }}</span>
```
and removed the `|safe` decorator in the script, like so,
```
<span class="username"><i class="fa fa-user fa-fw"></i> {{ user.username}}</span>
```
This allowed us to still enter scripts but the script did not execute like they did before.

__________________________________________________
## Insecure DOR
### Exposure
We found instances where Insecure Direct Object Reference attacks can occur primarily in the views.py file, where there are no authorization checks whe accessing object mainpulation views. Ex. 
```
def task_create(request, project_id):
    if request.method == 'POST':
        proj = Project.objects.get(pk=project_id)
        text = request.POST.get('text', False)
```
```
def task_edit(request, project_id, task_id):

    proj = Project.objects.get(pk=project_id)
    task = Task.objects.get(pk=task_id)
```

By Exploiting Insecure DOR, I can create, edit, and delete content that is not my own or use these insecure objects to access more information about the user

### Repair
To protect agains Insecure DOR, we included decorators such as,
```
@login_required(login_url='/login')
def task_edit(request, project_id, task_id):

    proj = Project.objects.get(pk=project_id)
    task = Task.objects.get(pk=task_id)
```
that require users to at least be signed in, similarly to how `user.is_authenticated` works. We can also specify users by permissions granted using `user.has_perm('admin')`.
__________________________________________________
## Security Misconfiguration
### Exposure
We found Security Misconfiguration in the by typing in an incorrect URL(`127.0.0.1:8000/taskManager/tut`) and we were returned a Django debug error page with the system urls check.

By exploiting security misconfiguration, we recieved an entire list of all the possible urls for the taskManager site which can expose session data and secret keys.

### Repair
We simply set all the DEBUG statements in settings.py to False, so verbose error messages will not be displayed and session data can remain mostly protected.
```
DEBUG = False
TEMPLATE_DEBUG = False

ALLOWED_HOSTS = []
```
Also storing the Secret_key in a virtual env is an effective way to make stealing session data much more difficult.

_________________________________________
## Exposure
### Exposure
We found routes for exposure through the site's multiple for fields that effect passwords. By typing in the `     `

By exploiting exposure, we gained access to all of the users' passwords from the database

### Repair
We fixed the password hashing vulnerability by changing the default hashing algorithm `django.contrib.auth.hashers.MD5PasswordHasher` with a more complicated hashing algorithm, like BCryptPasswordHasher that is already salted (`django.contrib.auth.hashers.BCryptPasswordHasher`). Also storing the `PASSWORD_HASHERS` in the virtualenv will help make getting the password even more difficult.

__________________________________________________
